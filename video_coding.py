# -*- coding: utf-8 -*-
"""handin_Data_preparation.ipynb

Automatically generated by Colaboratory.

Original file is located at
    https://colab.research.google.com/drive/19TAB_P31rh78M0nM_C8LfFu-foCfUKMH
"""

from google.colab import drive

drive.mount('/content/drive')

!pip install datetime

import os
import numpy as np
import cv2
import time
import pytz
from datetime import datetime
import random
# Definieer je tijdzone, bijvoorbeeld 'Europe/Amsterdam' voor Nederland
random.seed(42)
np.random.seed(42)
local_tz = pytz.timezone('Europe/Amsterdam')

# Huidige tijd in UTC krijgen
utc_dt = datetime.now(pytz.utc)

# Converteer UTC tijd naar lokale tijd
local_dt = utc_dt.astimezone(local_tz)

import random

"""# Data Loader"""

augment_count = 0
def augment_frame(frame):
    global augment_count
    augment_count += 1
    # if frame.dtype != np.uint8:
    #     frame = (255 * frame).astype(np.uint8)

    # Randomly flip the frame horizontally
    if random.random() > 0.5:
        frame = cv2.flip(frame, 1)

    # Random rotation between -10 and 10 degrees
    if random.random() > 0.5:
        angle = random.randint(-10, 10)
        h, w = frame.shape[:2]
        M = cv2.getRotationMatrix2D((w // 2, h // 2), angle, 1.0)
        frame = cv2.warpAffine(frame, M, (w, h))

    # Random brightness adjustment
    if random.random() > 0.5:
        frame = cv2.cvtColor(frame, cv2.COLOR_RGB2HSV)
        value = random.uniform(0.8, 1.2)
        frame = frame.astype(np.float32)  # Convert to float for manipulation
        frame[:, :, 2] *= value
        frame[:, :, 2] = np.clip(frame[:, :, 2], 0, 255)  # Clip to valid range
        frame = frame.astype(np.uint8)  # Convert back to uint8
        frame = cv2.cvtColor(frame, cv2.COLOR_HSV2RGB)

    return frame

def process_video(video_path, maxframes=49, imgsize=(224,224), augment=False):
    global augment_count
    augment_count = 0
    cap = cv2.VideoCapture(video_path)
    frames = []
    frame_count = int(cap.get(cv2.CAP_PROP_FRAME_COUNT))

    # if istrain:
    #     print('training check')
    #     if frame_count >= maxframes:
    #         selected_frames = np.random.choice(frame_count, maxframes, replace=False)
    #         selected_frames.sort()  # Sorteer voor consistentie
    #     else:
    #         selected_frames = np.arange(frame_count)  # Gebruik alle beschikbare frames
    # elif isval:
    #     print('val check')
    #     selected_frames = np.linspace(0, frame_count - 1, maxframes, dtype=int)
    # else:
    #     print('test check')
    #     selected_frames = np.arange(min(frame_count, maxframes))  # Neem de eerste 'maxframes' frames

    selected_frames = np.linspace(0, frame_count - 1, maxframes, dtype=int)
    for i in selected_frames:
        cap.set(cv2.CAP_PROP_POS_FRAMES, i)
        ret, frame = cap.read()
        if not ret:
            frame = np.zeros((imgsize[0], imgsize[1], 3), dtype=np.uint8)  # Gebruik een zero frame als fallback
        else:
            frame = cv2.cvtColor(frame, cv2.COLOR_BGR2RGB)
            frame = cv2.resize(frame, imgsize)
            if augment:
                frame = augment_frame(frame)  # Pas augmentatie toe
            # frame = frame / 255.0
            # frame = (frame - np.array([0.45, 0.45, 0.45])) / np.array([0.225, 0.225, 0.225])  # Normaliseer
        frames.append(frame)

    # Zero-padding totdat het aantal frames 'maxframes' bereikt
    while len(frames) < maxframes:
        frames.append(np.zeros((imgsize[0], imgsize[1], 3), dtype=np.uint8))

    cap.release()
    print(f'Total Augmenting Frames, count: {augment_count}')
    print(' ')
    output = np.array(frames, dtype=np.uint8)
    print(f'output shape X: {output.shape}')
    return np.array(frames, dtype=np.uint8)


# Een functie om de video's in een directory te verwerken en labels te extraheren
def load_videos_and_labels(directory,  augment=False):

    start_time = time.time()
    readable_time_start = time.strftime("%Y-%m-%d %H:%M:%S", time.localtime(start_time))
    print('start time:', readable_time_start)
    X = []
    y = []
    groups = []  # Deze lijst zal de groep-ID's bevatten
    video_files = [f for f in os.listdir(directory) if f.endswith('.mp4')]
    total_videos = len(video_files)
    for index, filename in enumerate(video_files, start=1):
        start = time.time()
        group_id = filename.split('-')[0]  # Neem aan dat dit de groep-ID format is
        label = filename.split('-')[-1].split('_')[-2]  # Haal het label op
        video_path = os.path.join(directory, filename)
        print(f"Loading video {index}/{total_videos}: {filename}, label: {label}, group: {group_id}")
        print(f"Augment: {augment}")
        frames = process_video(video_path, augment=augment)
        X.append(frames)
        y.append(label)
        groups.append(group_id)  # Voeg de groep-ID toe aan de lijst
    end_time = time.time()
    readable_time_end = time.strftime("%Y-%m-%d %H:%M:%S", time.localtime(end_time))
    elapsed_time = end_time - start_time
    print('end time:', readable_time_end)
    print('elapsed time:', elapsed_time/60, 'minutes')

    return np.array(X), np.array(y), np.array(groups)  # Retourneer X, y en groups

output_dir= '/content/drive/MyDrive/ThesisDSS/Thesis_V2/FINAL/data/_frms49_imgsze224'
extension = '_frms49_imgsze224_augmentfalse_normalizedfalse'

val_dir = '/content/drive/MyDrive/ThesisDSS/videodat_mp4/val'

X_val, y_val, groups_val = load_videos_and_labels(val_dir, augment=False)

np.save(f'{output_dir}/X_val{extension}.npy', X_val)
np.save(f'{output_dir}/y_val{extension}.npy', y_val)
np.save(f'{output_dir}/groups_val{extension}.npy', groups_val)

print("X_val shape:", X_val.shape)
print("X_val data type:", X_val.dtype)
print("y_val shape:", y_val.shape)
print("y_val data type:", y_val.dtype)
print('-'*50)
print(f"X_val Min pixel value: {X_val.min()}")
print(f"X_val Max pixel value: {X_val.max()}")
print(f"X_val Mean pixel value: {X_val.mean()}")
print('-'*50)

train_dir = '/content/drive/MyDrive/ThesisDSS/videodat_mp4/train'

X_train, y_train, groups_train = load_videos_and_labels(train_dir, augment=False)
np.save(f'{output_dir}/X_train_{extension}.npy', X_train)
np.save(f'{output_dir}/y_train_{extension}.npy',y_train)
np.save(f'{output_dir}/groups_train_{extension}.npy', groups_train)

test_dir ='/content/drive/MyDrive/ThesisDSS/videodat_mp4/test'

X_test, y_test, groups_test = load_videos_and_labels(test_dir, augment=False)

np.save(f'{output_dir}/X_test{extension}.npy', X_test)
np.save(f'{output_dir}/y_test{extension}.npy', y_test)
np.save(f'{output_dir}/groups_test{extension}.npy', groups_test)

train_dir = '/content/drive/MyDrive/ThesisDSS/videodat_mp4/train'

X_train, y_train, groups_train = load_videos_and_labels(train_dir, augment=True)
np.save(f'{output_dir}/X_train_augmented{extension}.npy', X_train)
np.save(f'{output_dir}/y_train_augmented{extension}.npy',y_train)
np.save(f'{output_dir}/groups_train_augmented{extension}.npy', groups_train)

print("X_train shape:", X_train.shape)
print("X_train data type:", X_train.dtype)
print("y_train shape:", y_train.shape)
print("y_train data type:", y_train.dtype)
print('-'*50)
print("X_val shape:", X_val.shape)
print("X_val data type:", X_val.dtype)
print("y_val shape:", y_val.shape)
print("y_val data type:", y_val.dtype)
print('-'*50)
print("X_test shape:", X_test.shape)
print("X_test data type:", X_test.dtype)
print("y_test shape:", y_test.shape)
print("y_test data type:", y_test.dtype)
print('-'*50)

print(f"X_train Min pixel value: {X_train.min()}")
print(f"X_train Max pixel value: {X_train.max()}")
print(f"X_train Mean pixel value: {X_train.mean()}")
print('-'*50)


print(f"X_val Min pixel value: {X_val.min()}")
print(f"X_val Max pixel value: {X_val.max()}")
print(f"X_val Mean pixel value: {X_val.mean()}")

print('-'*50)

print(f"X_train Min pixel value: {X_train.min()}")
print(f"X_train Max pixel value: {X_train.max()}")
print(f"X_train Mean pixel value: {X_train.mean()}")

from sklearn.preprocessing import LabelBinarizer

lb = LabelBinarizer()
y_train = lb.fit_transform(y_train)
y_val = lb.transform(y_val)
y_test = lb.transform(y_test)

np.save(f'{output_dir}/y_train_ohe{extension}.npy', y_train)

np.save(f'{output_dir}/y_val_ohe{extension}.npy', y_val)

np.save(f'{output_dir}/y_test_ohe{extension}.npy', y_test)

y_train = lb.inverse_transform(y_train)
y_val = lb.inverse_transform(y_val)
y_test = lb.inverse_transform(y_test)

"""# DataSplit"""

import matplotlib.pyplot as plt
import numpy as np

def plot_label_distribution(y_train, y_val, y_test, save_path):
    # Bepaal de unieke labels en hun hoeveelheden in de datasets
    unique_labels, counts_train = np.unique(y_train, return_counts=True)
    _, counts_val = np.unique(y_val, return_counts=True)
    _, counts_test = np.unique(y_test, return_counts=True)

    # Bepaal de posities van de bars
    bar_width = 0.25  # Verklein de bar breedte om ruimte te maken voor de derde set bars
    r1 = np.arange(len(counts_train))
    r2 = [x + bar_width for x in r1]
    r3 = [x + bar_width for x in r2]

    # Maak de plot
    fig, ax = plt.subplots(figsize=(12, 8))  # Vergroot de figuurgrootte indien nodig

    # Maak bars voor elke dataset
    train_bars = ax.bar(r1, counts_train, width=bar_width, label='Training Set', color='b')
    val_bars = ax.bar(r2, counts_val, width=bar_width, label='Validation Set', color='g')
    test_bars = ax.bar(r3, counts_test, width=bar_width, label='Test Set', color='r')

    # Voeg tekst toe boven de bars
    for bars in [train_bars, val_bars, test_bars]:
        for bar in bars:
            yval = bar.get_height()
            ax.text(bar.get_x() + bar.get_width() / 2.0, yval, int(yval), va='bottom', ha='center')

    # Voeg labels en titel toe
    ax.set_xlabel('Labels')
    ax.set_ylabel('Number of Samples')
    ax.set_title('Label Distribution in Training, Validation and Test Sets')

    # Voeg xticks toe
    ax.set_xticks([r + bar_width for r in r1])
    ax.set_xticklabels(unique_labels)

    # Voeg een legende toe
    ax.legend()

    # Organiseer de layout en sla de plot op
    plt.tight_layout()
    plt.savefig(save_path)

    # Toon de plot
    plt.show()

# Gebruik van de functie met een pad voor het opslaan van de plot
plot_label_distribution(y_train, y_val, y_test, f'{output_dir}/label_distribution_plot.png')